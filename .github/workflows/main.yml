name: CI/CD Pipeline to AWS EC2

on:
  push:
    branches:
      - main # Trigger on push to the main branch
  workflow_dispatch: # Allows manual triggering from GitHub UI

env:
  AWS_REGION: "eu-north-1"

jobs:
  # Job to build and push Docker image (This part is cloud-agnostic)
  build-and-push-docker:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: . # Path to your Dockerfile context (project root)
          file: ./nginx/Dockerfile.nginx # Path to your Dockerfile
          push: true
          tags: mohibulhasan/network-systemadmin-ca-01-web:1.0 # Your Docker Hub image and tag
          cache-from: type=gha # Use GitHub Actions cache for faster builds
          cache-to: type=gha,mode=max # Store build cache

  # Job to provision infrastructure with Terraform for AWS EC2
  terraform-apply:
    needs: build-and-push-docker # Depends on Docker image being built
    runs-on: ubuntu-latest
    outputs:
      vm_public_ip: ${{ steps.terraform-output.outputs.vm_public_ip }} # Pass EC2 Public IP to the next job
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.0 # Specifying desired Terraform version

      # --- AWS Authentication: Replaces Azure CLI login ---
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} # GitHub Secret for AWS Access Key ID
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} # GitHub Secret for AWS Secret Access Key
          aws-region: ${{ env.AWS_REGION }} # Use the AWS region defined in the workflow's env section

      - name: Terraform Init
        id: init
        run: terraform init
        working-directory: ./DeployTools/terraform # Path to your AWS Terraform files

      - name: Terraform Validate
        id: validate
        run: terraform validate
        working-directory: ./DeployTools/terraform

      - name: Terraform Apply
        id: apply
        run: terraform apply -auto-approve
        working-directory: ./DeployTools/terraform

      - name: Get EC2 Public IP from Terraform output
        id: terraform-output
        run: |
          # Assuming your AWS Terraform configuration outputs the EC2 public IP as 'vm_public_ip'
          VM_IP=$(terraform output -raw vm_public_ip)
          echo "vm_public_ip=$VM_IP" >> $GITHUB_OUTPUT
        working-directory: ./DeployTools/terraform

  # Job to deploy application with Ansible to AWS EC2
  ansible-deploy:
    needs: terraform-apply # Depends on Terraform provisioning the EC2 instance
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Ansible and Docker Python module
        run: pip install ansible docker # 'docker' is needed for Ansible's Docker modules

      - name: Set up SSH key for Ansible
        run: |
          mkdir -p ~/.ssh
          # Create a key file for Ansible SSH connection to EC2
          # It's good practice to give it a specific name like 'id_ec2_ansible.pem'
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ec2_ansible.pem
          chmod 400 ~/.ssh/id_ec2_ansible.pem # Set strict permissions for the private key

          # Add the EC2 instance's public IP to known_hosts to prevent SSH prompts
          ssh-keyscan -H ${{ needs.terraform-apply.outputs.vm_public_ip }} >> ~/.ssh/known_hosts

      - name: Create Ansible inventory for AWS EC2
        run: |
          mkdir -p inventory
          echo "[webservers]" > inventory/host.ini
          # Use the EC2 public IP from Terraform output
          # 'ansible_user=ubuntu' assumes your EC2 AMI uses 'ubuntu' as the default SSH user
          # 'ansible_ssh_private_key_file' points to the key we just set up
          echo "${{ needs.terraform-apply.outputs.vm_public_ip }} ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/id_ec2_ansible.pem" >> inventory/host.ini
        working-directory: ./DeployTools/ansible

      - name: Run Ansible Playbook - Deploy Dockerized Application
        # This assumes your main Ansible playbook for Docker deployment is named 'playbook.yml'
        # and is located in 'DeployTools/ansible'
        run: ansible-playbook -i inventory/host.ini playbook.yml
        working-directory: ./DeployTools/ansible
